Index: /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S	(working copy)
@@ -95,21 +95,25 @@
 
 	// handle return value
 
+	cmp %al, 'v'
+	je .return_void
 	cmp %al, 'd'
 	je .return_f64
 	cmp %al, 'f'
 	je .return_f32
 	cmp %al, 'l'
 	je .return_i64
-	cmp %al, 'i'
-	je .return_i32
-	ret
+	cmp %al, 'L'
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -121,3 +125,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+  	ret
Index: /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm	(working copy)
@@ -93,16 +93,19 @@
   mov  ebp, [ebp]                    ; EBP = parent frame
 
   ; handle return value
+  
+  cmp al, 'v'
+  je return_void
   cmp al, 'd'
   je return_f64
   cmp al, 'f'
   je return_f32
   cmp al, 'l'
   je return_i64
-  cmp al, 'i'
-  je return_i32
-  ret
-
+  cmp al, 'L'
+  je return_i64
+  ; All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
+  
 return_i32:
   mov  eax, [edx]
   ret
@@ -120,6 +123,9 @@
   fld qword ptr [edx]
   ret
 
+return_void:
+  ret
+
 _dcCallbackThunkEntry ENDP
 
 END
Index: /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s	(working copy)
@@ -44,10 +44,12 @@
 frame_DCArgs       = -24
 frame_DCValue      = -32
 
+ASCII_L = 76
 ASCII_l = 108
 ASCII_d	= 100
 ASCII_f = 102
 ASCII_i = 105
+ASCII_v = 118
 
 _dcCallbackThunkEntry:
 	push %ebp
@@ -96,21 +98,25 @@
 
 	// handle return value
 
+	cmp %al, ASCII_v
+	je .return_void
 	cmp %al, ASCII_d
 	je .return_f64
 	cmp %al, ASCII_f
 	je .return_f32
 	cmp %al, ASCII_l
 	je .return_i64
-	cmp %al, ASCII_i
-	je .return_i32
-	ret
+	cmp %al, ASCII_L
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case	
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -122,3 +128,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+	ret
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n64.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n64.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n64.c	(working copy)
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n64
 , &dc_callvm_argDouble_mips_n64
 , &dc_callvm_argPointer_mips_n64
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n64
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n64
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n64
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n64
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n64
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n64
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n64_ellipsis =
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_vector.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_vector.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_vector.c	(working copy)
@@ -22,14 +22,31 @@
 
 #include "dyncall_vector.h"
 #include <string.h>
+//void memcpy(void*, const void*, size_t);
 
 void dcVecAppend(DCVecHead* pHead, const void* pData, size_t size)
 {
-  if (pHead->mSize+size <= pHead->mTotal) 
+	size_t newSize = pHead->mSize + size;
+  if (newSize <= pHead->mTotal) 
   {
-    void* dst = (char*)dcVecData(pHead) + pHead->mSize;
-    memcpy(dst, pData, size); /* @@@ heavy for small types. */
-    pHead->mSize += size;
+  	void* dst = (char*)dcVecData(pHead) + pHead->mSize;
+  	switch (size) {
+  	case 1:
+  		*(char*)dst = *(const char*)pData;
+  		break;
+  	case 2:
+  		*(short*)dst = *(const short*)pData;
+  		break;
+  	case 4:
+  		*(int*)dst = *(const int*)pData;
+  		break;
+  	case 8:
+  		*(long long*)dst = *(const long long*)pData;
+  		break;
+  	default:
+  		memcpy(dst, pData, size); /* @@@ heavy for small types. */
+  	}
+    pHead->mSize = newSize;
   } 
 }
 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_eabi.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_eabi.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_eabi.c	(working copy)
@@ -152,6 +152,7 @@
 , &dc_callvm_argFloat_mips_eabi
 , &dc_callvm_argDouble_mips_eabi
 , &dc_callvm_argPointer_mips_eabi
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCboolvmfunc*)       &dc_callvm_call_mips_eabi
 , (DCcharvmfunc*)       &dc_callvm_call_mips_eabi
@@ -162,6 +163,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_eabi
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_eabi
 , (DCpointervmfunc*)    &dc_callvm_call_mips_eabi
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_eabi(DCsize size) 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/GNUmakefile
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/GNUmakefile	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/GNUmakefile	(working copy)
@@ -37,6 +37,7 @@
 INSTALL_LIB = 1
 
 UNITS = dyncall_vector dyncall_api 
+UNITS += dyncall_struct
 
 # @@@ disable dyncall_callf for pcc support temporarly
 ifdef BUILD_TOOL_pcc
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_api.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_api.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_api.c	(working copy)
@@ -85,6 +85,12 @@
   vm->mVTpointer->argPointer(vm,x); 
 }
 
+void dcArgStruct(DCCallVM* vm, DCstruct* s, DCpointer x) 
+{ 
+  vm->mVTpointer->argStruct(vm, s, x); 
+}
+
+
 void dcCallVoid(DCCallVM* vm, DCpointer funcptr) 
 {        
   vm->mVTpointer->callVoid(vm, funcptr); 
@@ -135,6 +141,11 @@
   return vm->mVTpointer->callPointer(vm, funcptr); 
 }
 
+void dcCallStruct(DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer x) 
+{ 
+  vm->mVTpointer->callStruct(vm, funcptr, s, x); 
+}
+
 DCint dcGetError(DCCallVM *vm)
 {
   return vm->mError;
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_x64.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_x64.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_x64.c	(working copy)
@@ -23,8 +23,8 @@
 
 #include "dyncall_callvm_x64.h"
 #include "dyncall_alloc.h"
+#include "dyncall_struct.h"
 
-
 static DCCallVM* dc_callvm_new_x64(DCCallVM_vt* vt, DCsize size)
 {
   DCCallVM_x64* self = (DCCallVM_x64*)dcAllocMem(sizeof(DCCallVM_x64)+size);
@@ -148,7 +148,16 @@
     dcVecAppend(&self->mVecHead, &x, sizeof(DCpointer));
 }
 
+static void dc_callvm_argStruct_x64(DCCallVM* in_self, DCstruct* s, DCpointer x)
+{
+  DCCallVM_x64* self = (DCCallVM_x64*)in_self;
+  dcVecAppend(&self->mVecHead, x, s->size);
+  
+  if (s->size <= 64)
+  	  dcArgStructUnroll(in_self, s, x);
+}
 
+
 /* Call. */
 void dc_callvm_call_x64(DCCallVM* in_self, DCpointer target)
 {
@@ -183,6 +192,7 @@
 , &dc_callvm_argFloat_x64
 , &dc_callvm_argDouble_x64
 , &dc_callvm_argPointer_x64
+, &dc_callvm_argStruct_x64
 , (DCvoidvmfunc*)       &dc_callvm_call_x64
 , (DCboolvmfunc*)       &dc_callvm_call_x64
 , (DCcharvmfunc*)       &dc_callvm_call_x64
@@ -193,6 +203,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x64
 , (DCdoublevmfunc*)     &dc_callvm_call_x64
 , (DCpointervmfunc*)    &dc_callvm_call_x64
+, NULL // argStruct
 };
 
 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_arm32_arm.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_arm32_arm.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_arm32_arm.c	(working copy)
@@ -163,6 +163,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -173,6 +174,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // callStruct
 };
 
 
@@ -190,6 +192,7 @@
 , &dc_callvm_argFloat_arm32_arm
 , &dc_callvm_argDouble_arm32_arm_eabi
 , &dc_callvm_argPointer_arm32_arm
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCboolvmfunc*)       &dc_callvm_call_arm32_arm
 , (DCcharvmfunc*)       &dc_callvm_call_arm32_arm
@@ -200,6 +203,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_arm32_arm
 , (DCdoublevmfunc*)     &dc_callvm_call_arm32_arm
 , (DCpointervmfunc*)    &dc_callvm_call_arm32_arm
+, NULL // argStruct
 };
 
 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm.h
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm.h	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm.h	(working copy)
@@ -49,6 +49,7 @@
   void         (*argFloat)       (DCCallVM* vm,DCfloat         f);
   void         (*argDouble)      (DCCallVM* vm,DCdouble        d);
   void         (*argPointer)     (DCCallVM* vm,DCpointer       p);
+  void         (*argStruct)      (DCCallVM* vm,DCstruct* s, DCpointer p);
   void         (*callVoid)       (DCCallVM* vm,DCpointer funcptr);
   DCbool       (*callBool)       (DCCallVM* vm,DCpointer funcptr);
   DCchar       (*callChar)       (DCCallVM* vm,DCpointer funcptr);
@@ -59,6 +60,7 @@
   DCfloat      (*callFloat)      (DCCallVM* vm,DCpointer funcptr);
   DCdouble     (*callDouble)     (DCCallVM* vm,DCpointer funcptr);
   DCpointer    (*callPointer)    (DCCallVM* vm,DCpointer funcptr);
+  void         (*callStruct)     (DCCallVM* vm,DCpointer funcptr,DCstruct* s, DCpointer returnValue);
 };
 
 typedef DCvoid       (DCvoidvmfunc)      (DCCallVM* vm,DCpointer funcptr); 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_ppc32.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_ppc32.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_ppc32.c	(working copy)
@@ -302,6 +302,7 @@
 , &dc_callvm_argFloat_ppc32_darwin
 , &dc_callvm_argDouble_ppc32_darwin
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_darwin
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_darwin
@@ -312,6 +313,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_darwin
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_darwin
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_darwin
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_ppc32_sysv =
@@ -328,6 +330,7 @@
 , &dc_callvm_argFloat_ppc32_sysv
 , &dc_callvm_argDouble_ppc32_sysv
 , &dc_callvm_argPointer_ppc32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCboolvmfunc*)       &dc_callvm_call_ppc32_sysv
 , (DCcharvmfunc*)       &dc_callvm_call_ppc32_sysv
@@ -338,6 +341,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_ppc32_sysv
 , (DCdoublevmfunc*)     &dc_callvm_call_ppc32_sysv
 , (DCpointervmfunc*)    &dc_callvm_call_ppc32_sysv
+, NULL // argStruct
 };
 
 void dc_callvm_mode_ppc32(DCCallVM* in_self, DCint mode)
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n32.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n32.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_n32.c	(working copy)
@@ -190,6 +190,7 @@
 , &dc_callvm_argFloat_mips_n32
 , &dc_callvm_argDouble_mips_n32
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -200,6 +201,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 DCCallVM_vt gVT_mips_n32_ellipsis =
@@ -216,6 +218,7 @@
 , &dc_callvm_argFloat_mips_n32_ellipsis
 , &dc_callvm_argDouble_mips_n32_ellipsis
 , &dc_callvm_argPointer_mips_n32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_n32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_n32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_n32
@@ -226,6 +229,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_n32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_n32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_n32
+, NULL // argStruct
 };
 
 static void dc_callvm_mode_mips_n32(DCCallVM* self,DCint mode)
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_o32.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_o32.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_mips_o32.c	(working copy)
@@ -199,6 +199,7 @@
 , &dc_callvm_argFloat_mips_o32
 , &dc_callvm_argDouble_mips_o32
 , &dc_callvm_argPointer_mips_o32
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_mips_o32
 , (DCboolvmfunc*)       &dc_callvm_call_mips_o32
 , (DCcharvmfunc*)       &dc_callvm_call_mips_o32
@@ -209,6 +210,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_mips_o32
 , (DCdoublevmfunc*)     &dc_callvm_call_mips_o32
 , (DCpointervmfunc*)    &dc_callvm_call_mips_o32
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_mips_o32(DCsize size) 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_signature.h
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_signature.h	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_signature.h	(working copy)
@@ -51,7 +51,9 @@
 #define DC_SIGCHAR_DOUBLE       'd'
 #define DC_SIGCHAR_POINTER      'p'
 #define DC_SIGCHAR_STRING       'Z'
-#define DC_SIGCHAR_ENDARG       ')'
+#define DC_SIGCHAR_STRUCT       'T'
+//#define DC_SIGCHAR_ALIGN        '0' // byte value to which '0' (zero digit) will be substracted to get the alignment
+#define DC_SIGCHAR_ENDARG       ')' // also works for end struct
 
 /* callback signatures */
 
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_x86.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_x86.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_callvm_x86.c	(working copy)
@@ -150,6 +150,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCboolvmfunc*)       &dc_callvm_call_x86_cdecl
 , (DCcharvmfunc*)       &dc_callvm_call_x86_cdecl
@@ -160,6 +161,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_cdecl
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_cdecl
 , (DCpointervmfunc*)    &dc_callvm_call_x86_cdecl
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_cdecl(DCsize size) 
@@ -197,6 +199,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_std
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_std
@@ -207,6 +210,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_std
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_std
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_std
+, NULL // argStruct
 };
 
 /* win32/std callvm allocator */
@@ -306,6 +310,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_ms
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -316,6 +321,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_ms(DCsize size) 
@@ -402,6 +408,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86_win32_fast_gnu
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_fast
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_fast
@@ -412,6 +419,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_fast
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_fast
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_fast
+, NULL // argStruct
 };
 
 DCCallVM* dcNewCallVM_x86_win32_fast_gnu(DCsize size) 
@@ -445,6 +453,7 @@
 , &dc_callvm_argFloat_x86
 , &dc_callvm_argDouble_x86
 , &dc_callvm_argPointer_x86
+, NULL // argStruct
 , (DCvoidvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCboolvmfunc*)       &dc_callvm_call_x86_win32_this_ms
 , (DCcharvmfunc*)       &dc_callvm_call_x86_win32_this_ms
@@ -455,6 +464,7 @@
 , (DCfloatvmfunc*)      &dc_callvm_call_x86_win32_this_ms
 , (DCdoublevmfunc*)     &dc_callvm_call_x86_win32_this_ms
 , (DCpointervmfunc*)    &dc_callvm_call_x86_win32_this_ms
+, NULL // argStruct
 };
 
 /* win32/this/ms callvm allocator */
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall.h
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall.h	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall.h	(working copy)
@@ -44,6 +44,7 @@
 #endif
 
 typedef struct DCCallVM_    DCCallVM;
+typedef struct DCstruct_    DCstruct;
 
 /* Supported Calling Convention Modes */
 
@@ -92,6 +93,7 @@
 DC_API void       dcArgFloat      (DCCallVM* vm, DCfloat    value);
 DC_API void       dcArgDouble     (DCCallVM* vm, DCdouble   value);
 DC_API void       dcArgPointer    (DCCallVM* vm, DCpointer  value);
+DC_API void       dcArgStruct     (DCCallVM* vm, DCstruct* s, DCpointer  value);
 
 DC_API void       dcCallVoid      (DCCallVM* vm, DCpointer funcptr);
 DC_API DCbool     dcCallBool      (DCCallVM* vm, DCpointer funcptr);
@@ -103,9 +105,25 @@
 DC_API DCfloat    dcCallFloat     (DCCallVM* vm, DCpointer funcptr);
 DC_API DCdouble   dcCallDouble    (DCCallVM* vm, DCpointer funcptr);
 DC_API DCpointer  dcCallPointer   (DCCallVM* vm, DCpointer funcptr);
+DC_API void       dcCallStruct    (DCCallVM* vm, DCpointer funcptr, DCstruct* s, DCpointer returnValue);
 
 DC_API DCint      dcGetError      (DCCallVM* vm);
 
+#define DEFAULT_ALIGNMENT -1
+DC_API DCstruct*  dcNewStruct     (DCsize fieldCount, DCint alignment);
+DC_API void       dcStructField   (DCstruct* s, DCint type, DCint alignment, DCsize arrayLength);
+DC_API void       dcSubStruct     (DCstruct* s, DCsize fieldCount, DCint alignment, DCsize arrayLength);  	
+// Each dcNewStruct or dcSubStruct call must be paired with a dcCloseStruct
+DC_API void       dcCloseStruct   (DCstruct* s);  	
+DC_API DCsize     dcStructSize    (DCstruct* s);  	
+DC_API DCsize     dcStructAlignment(DCstruct* s);  	
+DC_API void       dcFreeStruct    (DCstruct* s);
+
+DC_API DCstruct*  dcDefineStruct  (const char* signature);
+
+// Internal: move to some header (dyncall_structs.h for instance)
+void dcArgStructUnroll(DCCallVM* vm, DCstruct* s, DCpointer  value);
+
 #ifdef __cplusplus
 }
 #endif
Index: /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm	(working copy)
@@ -49,8 +49,8 @@
 
 	sub			rsp, rcx					; Setup stack frame by subtracting the size of the arguments.
 
-	mov			rax, rcx					; Align stack.
-	add			rax, 8
+	mov         rax, rsp                    ; Align stack.
+
 	and			rax, 15
 	sub			rsp, rax
 
Index: /home/ubuntu/src/dyncall/dyncall/dynload/dynload.h
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dynload/dynload.h	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dynload/dynload.h	(working copy)
@@ -24,6 +24,9 @@
 #ifndef DYNLOAD_H
 #define DYNLOAD_H
 
+
+#include "dyncall_macros.h"
+#include "dynload_macros.h"
 #include <stddef.h>
 #include <stdlib.h>
 
@@ -31,15 +34,19 @@
 extern "C" {
 #endif
 
+#ifndef DC_API
+#define DC_API
+#endif
+
 /* --- public api ---------------------------------------------------------- */
 
 /* shared library loading and explicit symbol resolving */
 
 typedef struct DLLib_ DLLib;
 
-DLLib* dlLoadLibrary(const char* libpath);
-void   dlFreeLibrary(DLLib* pLib);
-void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
+DC_API DLLib* dlLoadLibrary(const char* libpath);
+DC_API void   dlFreeLibrary(DLLib* pLib);
+DC_API void*  dlFindSymbol(DLLib* pLib, const char* pSymbolName);
 
 /* symbol table enumeration */
 
Index: /home/ubuntu/src/dyncall/dyncall/dynload/dynload_windows.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dynload/dynload_windows.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dynload/dynload_windows.c	(working copy)
@@ -32,7 +32,8 @@
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*) LoadLibraryA(libPath);
+  //return (DLLib*) LoadLibraryA(libPath);
+  return (DLLib*) LoadLibraryExA(libPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
 }
 
 void* dlFindSymbol(DLLib* libHandle, const char* symbol)
Index: /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms.c	(working copy)
@@ -17,12 +17,15 @@
 
 */
 
+#include "dynload.h"
+#include "dynload_macros.h"
 #include "dyncall_macros.h"
+#include "dyncall_alloc.h"
 
 #if defined(DC_WINDOWS)
 #  include "dynload_syms_pe.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin) 
+#  if defined (DC__OS_Darwin)
 #    include "dynload_syms_mach-o.c"
 #  else
 #    include "dynload_syms_elf.c"
Index: /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c	(working copy)
@@ -33,9 +33,11 @@
 
 #if defined(DC__Arch_AMD64)
 #define MACH_HEADER_TYPE mach_header_64
+#define SEGMENT_COMMAND segment_command_64
 #define NLIST_TYPE nlist_64
 #else
 #define MACH_HEADER_TYPE mach_header
+#define SEGMENT_COMMAND segment_command
 #define NLIST_TYPE nlist
 #endif
 
@@ -67,8 +69,13 @@
 		const char* name = _dyld_get_image_name(iImage);
 		if (name && !strcmp(name, pLib->libPath))
 		{
-			const struct mach_header* pHeader = _dyld_get_image_header(iImage);
-			const char* pBase = (const char*)pHeader;
+			const struct MACH_HEADER_TYPE* pHeader = _dyld_get_image_header(iImage);
+			const char* pBase = ((const char*)pHeader);
+			if (pHeader->filetype != MH_DYLIB)
+				return NULL;
+			if (pHeader->flags & MH_SPLIT_SEGS)
+				return NULL;
+
 			if (pHeader)
 			{
 				uint32_t iCmd, nCmds = pHeader->ncmds;
@@ -106,7 +113,6 @@
 	dcFreeMem(pSyms);
 }
 
-
 int dlSymsCount(DLSyms* pSyms)
 {
 	if (!pSyms)
@@ -114,7 +120,6 @@
 	return pSyms->symbolCount;
 }
 
-
 static const struct NLIST_TYPE* get_nlist(DLSyms* pSyms, int index)
 {
 	const struct NLIST_TYPE* nl;
Index: /home/ubuntu/src/dyncall/dyncall/dynload/dynload.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dynload/dynload.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dynload/dynload.c	(working copy)
@@ -18,11 +18,14 @@
 */
 
 #include "dynload.h"
+//#include "dynload_macros.h"
 #include "dyncall_macros.h"
+//#include "dyncall_alloc.h"
+
 #if defined(DC_WINDOWS)
 #  include "dynload_windows.c"
 #elif defined(DC_UNIX)
-#  if defined (DC__OS_Darwin)
+#  if defined(DC__OS_Darwin)
 #    include "dynload_darwin.c"
 #  else
 #    include "dynload_unix.c"
Index: /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms_elf.c
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms_elf.c	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/dynload/dynload_syms_elf.c	(working copy)
@@ -20,6 +20,7 @@
 
 #if defined(DC__OS_Linux) && !defined(_GNU_SOURCE)
 #define _GNU_SOURCE
+#define __USE_GNU
 #endif
 
 /*
Index: /home/ubuntu/src/dyncall/dyncall/buildsys/gmake/prolog.gmake
===================================================================
--- /home/ubuntu/src/dyncall/dyncall/buildsys/gmake/prolog.gmake	(revision 753)
+++ /home/ubuntu/src/dyncall/dyncall/buildsys/gmake/prolog.gmake	(working copy)
@@ -28,6 +28,7 @@
 
 # config settings
 
+#$(if $(wildcard "${TOP}/ConfigVars"),$(error hmm),$(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.))
 ifeq ($(wildcard $(TOP)/ConfigVars),)
 $(error File 'ConfigVars' not found at top directory. Run 'configure' - or, if you use CMake, run 'make -f Makefile' please.)
 else
