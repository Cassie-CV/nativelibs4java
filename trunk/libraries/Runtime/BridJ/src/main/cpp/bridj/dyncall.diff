Index: /Users/ochafik/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm
===================================================================
--- /Users/ochafik/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm	(revision 576)
+++ /Users/ochafik/src/dyncall/dyncall/dyncall/dyncall_call_x64_masm.asm	(working copy)
@@ -49,8 +49,7 @@
 
 	sub			rsp, rcx					; Setup stack frame by subtracting the size of the arguments.
 
-	mov			rax, rcx					; Align stack.
-	add			rax, 8
+	mov			rax, rsp					; Align stack.
 	and			rax, 15
 	sub			rsp, rax
 
Index: /Users/ochafik/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c
===================================================================
--- /Users/ochafik/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c	(revision 576)
+++ /Users/ochafik/src/dyncall/dyncall/dynload/dynload_syms_mach-o.c	(working copy)
@@ -31,9 +31,11 @@
 
 #if defined(DC__Arch_AMD64)
 #define MACH_HEADER_TYPE mach_header_64
+#define SEGMENT_COMMAND segment_command_64
 #define NLIST_TYPE nlist_64
 #else
 #define MACH_HEADER_TYPE mach_header
+#define SEGMENT_COMMAND segment_command
 #define NLIST_TYPE nlist
 #endif
 
@@ -66,12 +68,17 @@
 		if (name && !strcmp(name, pLib->libPath))
 		{
 			const struct MACH_HEADER_TYPE* pHeader = _dyld_get_image_header(iImage);
-			const char* pBase = (const char*)pHeader;
+			const char* pBase = ((const char*)pHeader);
+			if (pHeader->filetype != MH_DYLIB)
+				return NULL;
+			if (pHeader->flags & MH_SPLIT_SEGS)
+				return NULL;
+
 			if (pHeader)
 			{
 				uint32_t iCmd, nCmds = pHeader->ncmds;
 				const struct load_command* cmd = (const struct load_command*)(pBase + sizeof(struct MACH_HEADER_TYPE));
-				
+
 				for (iCmd = 0; iCmd < nCmds; iCmd++) 
 				{
 					if (cmd->cmd == LC_SYMTAB) 
@@ -120,6 +127,13 @@
 		return NULL;
 	
 	nl = pSyms->pSymbolTable + index;
+
+//	if (!nl->n_value // undefined
+//		|| nl->n_type >= N_PEXT //|| // debug symbol
+//		|| !(nl->n_type & N_EXT)
+//	)
+//		return NULL;
+
 	if (nl->n_un.n_strx <= 1)
 		return NULL; // would be empty string anyway
 	
Index: /Users/ochafik/src/dyncall/dyncall/dynload/dynload_syms_elf.c
===================================================================
--- /Users/ochafik/src/dyncall/dyncall/dynload/dynload_syms_elf.c	(revision 576)
+++ /Users/ochafik/src/dyncall/dyncall/dynload/dynload_syms_elf.c	(working copy)
@@ -23,6 +23,10 @@
  dynamic symbol resolver for elf
 
  */
+ 
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
 
 #include "dynload.h"
 #include "dynload_macros.h"
Index: /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S
===================================================================
--- /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S	(revision 576)
+++ /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_gas.S	(working copy)
@@ -95,21 +95,25 @@
 
 	// handle return value
 
+	cmp %al, 'v'
+	je .return_void
 	cmp %al, 'd'
 	je .return_f64
 	cmp %al, 'f'
 	je .return_f32
 	cmp %al, 'l'
 	je .return_i64
-	cmp %al, 'i'
-	je .return_i32
-	ret
+	cmp %al, 'L'
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -121,3 +125,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+	ret
Index: /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm
===================================================================
--- /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm	(revision 576)
+++ /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_masm.asm	(working copy)
@@ -93,16 +93,19 @@
   mov  ebp, [ebp]                    ; EBP = parent frame
 
   ; handle return value
+  
+  cmp al, 'v'
+  je return_void
   cmp al, 'd'
   je return_f64
   cmp al, 'f'
   je return_f32
   cmp al, 'l'
   je return_i64
-  cmp al, 'i'
-  je return_i32
-  ret
-
+  cmp al, 'L'
+  je return_i64
+  ; All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case
+  
 return_i32:
   mov  eax, [edx]
   ret
@@ -120,6 +123,9 @@
   fld qword ptr [edx]
   ret
 
+return_void:
+  ret
+
 _dcCallbackThunkEntry ENDP
 
 END
Index: /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s
===================================================================
--- /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s	(revision 576)
+++ /Users/ochafik/src/dyncall/dyncall/dyncallback/dyncall_callback_x86_apple.s	(working copy)
@@ -44,10 +44,12 @@
 frame_DCArgs       = -24
 frame_DCValue      = -32
 
+ASCII_L = 76
 ASCII_l = 108
 ASCII_d	= 100
 ASCII_f = 102
 ASCII_i = 105
+ASCII_v = 118
 
 _dcCallbackThunkEntry:
 	push %ebp
@@ -96,21 +98,25 @@
 
 	// handle return value
 
+	cmp %al, ASCII_v
+	je .return_void
 	cmp %al, ASCII_d
 	je .return_f64
 	cmp %al, ASCII_f
 	je .return_f32
 	cmp %al, ASCII_l
 	je .return_i64
-	cmp %al, ASCII_i
-	je .return_i32
-	ret
+	cmp %al, ASCII_L
+	je .return_i64_
+	
+	// All int cases <= 32 bits (+ pointer & string cases) fall in the 32 bits int case	
 
 .return_i32:
 	mov  %eax, [%edx]
 	ret
 
 .return_i64:
+.return_i64_:
 	mov  %eax, [%edx]
 	mov  %edx, [%edx+4]
 	ret
@@ -122,3 +128,6 @@
 .return_f64:
 	fld qword ptr [%edx]
 	ret
+
+.return_void:
+	ret
