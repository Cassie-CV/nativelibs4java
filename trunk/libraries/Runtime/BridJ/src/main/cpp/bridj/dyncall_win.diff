Index: dyncall/dyncall/dyncall_call_x64_masm.asm
===================================================================
--- dyncall/dyncall/dyncall_call_x64_masm.asm	(revision 559)
+++ dyncall/dyncall/dyncall_call_x64_masm.asm	(working copy)
@@ -31,7 +31,7 @@
 
 
 ; Main dyncall call.
-dcCall_x64_win64 PROC EXPORT
+dcCall_x64_win64 PROC
 
 	OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
Index: dyncall/dyncall/dyncall_call_x86_masm.asm
===================================================================
--- dyncall/dyncall/dyncall_call_x86_masm.asm	(revision 559)
+++ dyncall/dyncall/dyncall_call_x86_masm.asm	(working copy)
@@ -33,7 +33,7 @@
 
 
 ; Main dyncall call.
-_dcCall_x86_cdecl PROC EXPORT
+_dcCall_x86_cdecl PROC
 
     OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
@@ -71,7 +71,7 @@
 _dcCall_x86_cdecl ENDP
 
 
-_dcCall_x86_win32_msthis PROC EXPORT
+_dcCall_x86_win32_msthis PROC ; EXPORT
 
     OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
@@ -114,7 +114,7 @@
 _dcCall_x86_win32_msthis ENDP
 
 
-_dcCall_x86_win32_std PROC EXPORT
+_dcCall_x86_win32_std PROC ; EXPORT
 
     OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
@@ -151,7 +151,7 @@
 _dcCall_x86_win32_std ENDP
 
 
-_dcCall_x86_win32_fast PROC EXPORT
+_dcCall_x86_win32_fast PROC ; EXPORT
 
     OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
Index: dyncall/dyncallback/dyncall_callback_ppc32.c
===================================================================
--- dyncall/dyncallback/dyncall_callback_ppc32.c	(revision 559)
+++ dyncall/dyncallback/dyncall_callback_ppc32.c	(working copy)
@@ -48,6 +48,6 @@
 
 void dcbFreeCallback(DCCallback* pcb)
 {
-  dcbFreeWX(pcb, sizeof(DCCallback));
+  dcFreeWX(pcb, sizeof(DCCallback));
 }
 
Index: dyncall/dyncallback/dyncall_callback_x64_masm.asm
===================================================================
--- dyncall/dyncallback/dyncall_callback_x64_masm.asm	(revision 559)
+++ dyncall/dyncallback/dyncall_callback_x64_masm.asm	(working copy)
@@ -45,7 +45,7 @@
 DCCallback_size =   40
 
 
-dcCallbackThunkEntry PROC EXPORT
+dcCallbackThunkEntry PROC
 
   OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
Index: dyncall/dyncallback/dyncall_callback_x86_masm.asm
===================================================================
--- dyncall/dyncallback/dyncall_callback_x86_masm.asm	(revision 559)
+++ dyncall/dyncallback/dyncall_callback_x86_masm.asm	(working copy)
@@ -49,7 +49,7 @@
 frame_DCArgs      = -24
 frame_DCValue     = -32
 
-_dcCallbackThunkEntry PROC EXPORT
+_dcCallbackThunkEntry PROC
 
   OPTION PROLOGUE:NONE, EPILOGUE:NONE
 
Index: dyncall/dyncallback/GNUmakefile
===================================================================
--- dyncall/dyncallback/GNUmakefile	(revision 559)
+++ dyncall/dyncallback/GNUmakefile	(working copy)
@@ -60,6 +60,7 @@
 UNITS += dyncall_callback_x86_masm
 endif
 ifdef BUILD_ARCH_x64
+UNITS += dyncall_callback_x64
 UNITS += dyncall_callback_x64_masm
 endif
 endif
Index: dyncall/dynload/dynload.c
===================================================================
--- dyncall/dynload/dynload.c	(revision 559)
+++ dyncall/dynload/dynload.c	(working copy)
@@ -21,6 +21,10 @@
 #if defined(DC_WINDOWS)
 #include "dynload_win32.c"
 #elif defined(DC_UNIX)
-#include "dynload_unix.c"
+# if defined (DC__OS_Darwin)
+# include "dynload_darwin.c"
+# else
+# include "dynload_unix.c"
+# endif
 #endif
 
Index: dyncall/dynload/dynload.h
===================================================================
--- dyncall/dynload/dynload.h	(revision 559)
+++ dyncall/dynload/dynload.h	(working copy)
@@ -54,13 +54,14 @@
 
 typedef struct DLSyms_ DLSyms;
 
-size_t      dlSyms_sizeof();
-void        dlSymsInit   (DLSyms* pSyms, DLLib* pLib);
+DLSyms*     dlSymsInit   (DLLib* pLib);
 void        dlSymsCleanup(DLSyms* pSyms);
 
 int         dlSymsCount  (DLSyms* pSyms);
 const char* dlSymsName   (DLSyms* pSyms, int index);
 void*       dlSymsValue  (DLSyms* pSyms, int index);
+const char* dlSymsNameFromValue(DLSyms* pSyms, void* value);
+const char* dlSymsNameFromValue(DLSyms* pSyms, void* value);
 
 #ifdef __cplusplus
 }
Index: dyncall/dynload/dynload_darwin.c
===================================================================
--- dyncall/dynload/dynload_darwin.c	(revision 0)
+++ dyncall/dynload/dynload_darwin.c	(revision 0)
@@ -0,0 +1,71 @@
+/*
+
+ Copyright (c) 2007-2009 Olivier Chafik <olivier.chafik@gmail.com>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+/*
+
+  dynload_darwin.c
+
+  dynload module for .dylib (mach-o darwin/OS X) files
+
+*/
+
+
+#include "dynload.h"
+
+#include <dlfcn.h>
+
+struct DLLib_
+{
+	char* libPath;
+	void* handle;
+};
+
+DLLib* dlLoadLibrary(const char* libPath)
+{
+	void* handle;
+	size_t len;
+	DLLib* lib;
+	
+	handle = dlopen(libPath, RTLD_LAZY);
+	if (!handle)
+		return NULL;
+	
+	len = strlen(libPath);
+	lib = (DLLib*)malloc(sizeof(DLLib));
+	lib->libPath = (char*)malloc(len + 1);
+	strcpy(lib->libPath, libPath);
+	lib->libPath[len] = '\0';
+	lib->handle = handle;
+	return lib;
+}
+
+void* dlFindSymbol(DLLib* libHandle, const char* symbol)
+{
+  return dlsym(libHandle && libHandle->handle ? libHandle->handle : RTLD_DEFAULT, symbol);
+}
+
+void  dlFreeLibrary(DLLib* libHandle)
+{
+	if (!libHandle)
+		return;
+	
+	dlclose(libHandle->handle);
+	free(libHandle->libPath);
+	free(libHandle);
+}
+
Index: dyncall/dynload/dynload_syms.c
===================================================================
--- dyncall/dynload/dynload_syms.c	(revision 559)
+++ dyncall/dynload/dynload_syms.c	(working copy)
@@ -23,11 +23,10 @@
 # include "dynload_syms_pe32.c"
 #elif defined(DC_UNIX)
 # if defined (DC__OS_Darwin)
-void dummy() { }
+# include "dynload_syms_darwin.c"
 # else
 # include "dynload_syms_elf.c"
 # endif
 #else
 void dummy() { }
 #endif
-
Index: dyncall/dynload/dynload_syms_darwin.c
===================================================================
--- dyncall/dynload/dynload_syms_darwin.c	(revision 0)
+++ dyncall/dynload/dynload_syms_darwin.c	(revision 0)
@@ -0,0 +1,113 @@
+/*
+
+ Copyright (c) 2007-2009 Olivier Chafik <olivier.chafik@gmail.com>
+
+ Permission to use, copy, modify, and distribute this software for any
+ purpose with or without fee is hereby granted, provided that the above
+ copyright notice and this permission notice appear in all copies.
+
+ THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+*/
+
+/*
+ 
+ dynamic symbol resolver for Mach-O
+
+ */
+
+#include "dynload.h"
+#include "dynload_macros.h"
+#include <mach-o/dyld.h>
+#include <stdio.h>
+
+#include <dlfcn.h>
+
+void dummy() { }
+
+struct DLLib_
+{
+	char* libPath;
+	void* handle;
+};
+
+struct DLSyms_
+{
+	DLLib* pLib;
+	NSObjectFileImage pObjectFileImage;
+};
+
+DLSyms* dlSymsInit(DLLib* pLib)
+{
+	DLSyms* pSyms;
+	int ret;
+	if (!pLib)
+		return NULL;
+	
+	pSyms = (DLSyms*)malloc(sizeof(DLSyms));
+	pSyms->pLib = pLib;
+	pSyms->pObjectFileImage = NULL;
+
+	ret = NSCreateObjectFileImageFromFile(
+		pLib->libPath, 
+		&pSyms->pObjectFileImage
+	);
+	if (ret != NSObjectFileImageSuccess) {
+		
+	}
+}
+
+void dlSymsCleanup(DLSyms* pSyms)
+{
+	if (!pSyms)
+		return;
+	
+	if (pSyms->pObjectFileImage)
+		NSDestroyObjectFileImage(pSyms->pObjectFileImage);
+	
+	free(pSyms);
+}
+
+int dlSymsCount(DLSyms* pSyms)
+{
+	if (!pSyms || !pSyms->pObjectFileImage)
+		return 0;
+	return NSSymbolDefinitionCountInObjectFileImage(pSyms->pObjectFileImage);
+}
+
+const char* dlSymsName(DLSyms* pSyms, int index)
+{
+	if (!pSyms->pObjectFileImage)
+		return NULL;
+	return NSSymbolDefinitionNameInObjectFileImage(pSyms->pObjectFileImage, index);
+}
+
+void* dlSymsValue(DLSyms* pSyms, int index)
+{
+	const char* name = dlSymsName(pSyms, index);
+	if (!name)
+		return NULL;
+	return dlFindSymbol(pSyms->pLib, name);
+}
+/*void* dlSymsNameValue(DLSyms* pSyms, int index, const char** nameOut) {
+	if (!pSyms->pObjectFileImage)
+		return false;
+	
+	*nameOut = NSSymbolDefinitionNameInObjectFileImage(pSyms->pObjectFileImage, index);
+	return *nameOut ? dlFindSymbol(pSyms->pLib, *nameOut) : NULL;
+}*/
+
+const char* dlSymsNameFromValue(DLSyms* pSyms, void* value)
+{
+  Dl_info info;
+  if (dladdr(value, &info) && (value == info.dli_saddr))
+    return "";//info.dli_sname;
+  return NULL;
+}
+
Index: dyncall/dynload/dynload_syms_elf.c
===================================================================
--- dyncall/dynload/dynload_syms_elf.c	(revision 559)
+++ dyncall/dynload/dynload_syms_elf.c	(working copy)
@@ -105,15 +105,15 @@
   uint32_t*     pGNUHashChain;
 };
 
-size_t dlSyms_sizeof()
-{
-  return sizeof(DLSyms);
-}
 #include <stdio.h>
-void dlSymsInit(DLSyms* pSyms, DLLib* pLib)
+
+DLSyms* dlSymsInit(DLLib* pLib)
 {
-  assert(pSyms && pLib);
+  DLSyms* pSyms;
+  if (!pLib)
+	  return NULL;
   
+  pSyms = (DLSyms*)malloc(sizeof(DLSyms));
   pSyms->pStrTab  = 0;
   pSyms->pSymTab  = 0;
   pSyms->pHash    = 0;
@@ -173,16 +173,19 @@
     uint32_t* pchain   = (uint32_t*) &pbuckets[p->nbuckets];
     pSyms->pGNUHashChain = pchain;
   }
+  return pSyms;
 }
 
 void dlSymsCleanup(DLSyms* pSyms)
 {
-  /* do nothing. */
+  free(pSyms);
 }
 
 int dlSymsCount(DLSyms* pSyms)
 {
-  assert(pSyms && pSyms->pHash);
+  if (!pSyms || !pSyms->pHash)
+    return 0;
+
   if (pSyms->pGNUHash) {
     return pSyms->pHash->nchain - pSyms->pGNUHash->symndx;
   } else {
@@ -192,8 +195,10 @@
 
 const char* dlSymsName(DLSyms* pSyms, int index)
 {
-  assert(pSyms && pSyms->pSymTab && pSyms->pStrTab );
   int export_base;
+  if (!pSyms || !pSyms->pSymTab || !pSyms->pStrTab)
+    return NULL;
+
   if (pSyms->pGNUHash) {
     export_base = pSyms->pGNUHash->symndx;
   } else {
@@ -205,8 +210,10 @@
 
 void* dlSymsValue(DLSyms* pSyms, int index)
 {
-  assert(pSyms && pSyms->pSymTab);
   int export_base;
+  if (!pSyms || !pSyms->pSymTab)
+    return NULL;
+  
   if (pSyms->pGNUHash) {
     export_base = pSyms->pGNUHash->symndx;
   } else {
@@ -344,8 +351,9 @@
   // return 0;
 }
 
-void dlInitSyms_elf32(DLSyms* pResolver, DLLib* pLib)
+void dlInitSyms_elf32(DLLib* pLib)
 {
+  DLSyms* pResolver = (DLSyms*)malloc(sizeof(DLSyms));
   pResolver->elf64 = 0;
   Elf32_Ehdr* pH   = pLib->u.pElf32_Ehdr;
   assert(pH->e_phoff > 0);
@@ -388,3 +396,11 @@
 }
 #endif
 
+const char* dlSymsNameFromValue(DLSyms* pSyms, void* value)
+{
+  Dl_info info;
+  if (dladdr(value, &info) && (value == info.dli_saddr))
+    return info.dli_sname;
+  return NULL;
+}
+
Index: dyncall/dynload/dynload_syms_pe32.c
===================================================================
--- dyncall/dynload/dynload_syms_pe32.c	(revision 559)
+++ dyncall/dynload/dynload_syms_pe32.c	(working copy)
@@ -20,6 +20,7 @@
 #include "dynload.h"
 
 #include <windows.h>
+#include <Dbghelp.h>
 
 struct DLLib_
 {
@@ -28,10 +29,12 @@
 
 struct DLSyms_
 {
+  DLLib* pLib;
   const char* pBase;
-  ptrdiff_t* pNames;
-  ptrdiff_t* pFuncs;
-  size_t     count;
+  const DWORD* pNames;
+  const DWORD* pFuncs;
+  const unsigned short* pOrds;
+  size_t count;
 };
 
 size_t dlSyms_sizeof()
@@ -39,22 +42,31 @@
   return sizeof(DLSyms);
 }
 
-void dlSymsInit(DLSyms* pResolver, DLLib* pLib)
+DLSyms* dlSymsInit(DLLib* pLib)
 {
-  const char* ptr = (const char*) pLib;
-  IMAGE_DOS_HEADER*       pDOSHeader      = (IMAGE_DOS_HEADER*) ptr;  
-  IMAGE_NT_HEADERS*       pNTHeader       = (IMAGE_NT_HEADERS*) ( ptr + pDOSHeader->e_lfanew );  
+  DLSyms* pResolver = (DLSyms*)malloc(sizeof(DLSyms));
+  const char* base = (const char*) pLib;
+  IMAGE_DOS_HEADER*       pDOSHeader      = (IMAGE_DOS_HEADER*) base;  
+  IMAGE_NT_HEADERS*       pNTHeader       = (IMAGE_NT_HEADERS*) ( base + pDOSHeader->e_lfanew );  
   IMAGE_DATA_DIRECTORY*   pExportsDataDir = &pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
-  IMAGE_EXPORT_DIRECTORY* pExports        = (IMAGE_EXPORT_DIRECTORY*) (ptr + pExportsDataDir->VirtualAddress);  
-  pResolver->pBase  = ptr;
-  pResolver->pNames = (ptrdiff_t*) ( ptr + ( (ptrdiff_t)pExports->AddressOfNames) );
-  pResolver->pFuncs = (ptrdiff_t*) ( ptr+( (ptrdiff_t) pExports->AddressOfFunctions) );
-  pResolver->count  = (size_t)       pExports->NumberOfNames;
+  IMAGE_EXPORT_DIRECTORY* pExports        = (IMAGE_EXPORT_DIRECTORY*) (base + pExportsDataDir->VirtualAddress);  
+  
+  pResolver->pBase	= base;
+  pResolver->pNames = (DWORD*)(base + pExports->AddressOfNames);
+  pResolver->pFuncs = (DWORD*)(base + pExports->AddressOfFunctions);
+  pResolver->pOrds	= (unsigned short*)(base + pExports->AddressOfNameOrdinals);
+  pResolver->count  = (size_t)pExports->NumberOfNames;
+  pResolver->pLib   = pLib;
+  SymSetOptions(//SYMOPT_UNDNAME | 
+	  SYMOPT_DEFERRED_LOADS);
+  //SymInitialize((HANDLE)pLib, NULL, TRUE);
+  SymInitialize(GetCurrentProcess(), NULL, TRUE);
+  return pResolver;
 }
 
 void dlSymsCleanup(DLSyms* pResolver)
 {
-  /* do nothing. */
+  SymCleanup(GetCurrentProcess());
 }
 
 int dlSymsCount(DLSyms* pResolver)
@@ -67,34 +79,35 @@
   IMAGE_EXPORT_DIRECTORY* pExports        = (IMAGE_EXPORT_DIRECTORY*) (ptr + pExportsDataDir->VirtualAddress);  
   return pExports->NumberOfNames;
 */
-  return pResolver->count;
+  return (int)pResolver->count;
 }
 
 const char* dlSymsName(DLSyms* pResolver, int index)
 {
-/*
-  unsigned char* ptr = (unsigned char*) handle;
-  IMAGE_DOS_HEADER*       pDOSHeader      = (IMAGE_DOS_HEADER*) ptr;  
-  IMAGE_NT_HEADERS*       pNTHeader       = (IMAGE_NT_HEADERS*) ( ptr + pDOSHeader->e_lfanew );  
-  IMAGE_DATA_DIRECTORY*   pExportsDataDir = &pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
-  IMAGE_EXPORT_DIRECTORY* pExports        = (IMAGE_EXPORT_DIRECTORY*) (ptr + pExportsDataDir->VirtualAddress);  
-  ptrdiff_t* pNames = (ptrdiff_t*) ( ptr + ( (ptrdiff_t)pExports->AddressOfNames) );
-  return (const char*) ( ptr + pNames[index] );
-*/
-  return (const char*) ( ( (const char*) pResolver->pBase ) + pResolver->pNames[index] );
+  return (const char*)((BYTE*)pResolver->pBase + pResolver->pNames[index]);
 }
 
 void* dlSymsValue(DLSyms* pResolver, int index)
 {
-/*
-  unsigned char* ptr = (unsigned char*) handle;
-  IMAGE_DOS_HEADER*       pDOSHeader      = (IMAGE_DOS_HEADER*) ptr;  
-  IMAGE_NT_HEADERS*       pNTHeader       = (IMAGE_NT_HEADERS*) ( ptr + pDOSHeader->e_lfanew );  
-  IMAGE_DATA_DIRECTORY*   pExportsDataDir = &pNTHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
-  IMAGE_EXPORT_DIRECTORY* pExports        = (IMAGE_EXPORT_DIRECTORY*) (ptr + pExportsDataDir->VirtualAddress);  
-  ptrdiff_t* pFuncs = (ptrdiff_t*) ( ptr+( (ptrdiff_t) pExports->AddressOfFunctions) );
-  return (void*) ( ptr + pFuncs[index] );
-*/
-  return (void*) ( pResolver->pBase + pResolver->pFuncs[index] );
+  return (void*)((void**)pResolver->pBase + pResolver->pFuncs[pResolver->pOrds[index]]);
 }
 
+const char* dlSymsNameFromValue(DLSyms* pResolver, void* value) 
+{
+    DWORD64  dwAddress = (DWORD64)value;
+    DWORD64  dwDisplacement = 0;
+    ULONG64 buffer[(
+        sizeof(SYMBOL_INFO) +
+        MAX_SYM_NAME * sizeof(TCHAR) +
+        sizeof(ULONG64) - 1) /
+        sizeof(ULONG64)
+    ];
+    PSYMBOL_INFO pSymbol = (PSYMBOL_INFO) buffer;
+    pSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);
+    pSymbol->MaxNameLen = MAX_SYM_NAME;
+    
+	if (SymFromAddr(GetCurrentProcess(), dwAddress, &dwDisplacement, pSymbol) && !dwDisplacement)
+		return pSymbol->Name;
+
+    return NULL;
+}
Index: dyncall/dynload/dynload_unix.c
===================================================================
--- dyncall/dynload/dynload_unix.c	(revision 559)
+++ dyncall/dynload/dynload_unix.c	(working copy)
@@ -45,3 +45,19 @@
   dlclose( (void*) libHandle);
 }
 
+const char* dlSymsNameFromValue(DLSyms* pSyms, void* value)
+{
+  Dl_info info;
+  if (dladdr(value, &info) && (value == info.dli_saddr))
+    return info.dli_fname;
+  return NULL;
+}
+
+const char* dlSymsNameFromValue(DLSyms* pSyms, void* value)
+{
+  Dl_info info;
+  if (dladdr(value, &info) && (value == info.dli_saddr))
+    return info.dli_fname;
+  return NULL;
+}
+
Index: dyncall/test/nm/nm.c
===================================================================
--- dyncall/test/nm/nm.c	(revision 559)
+++ dyncall/test/nm/nm.c	(working copy)
@@ -24,11 +24,8 @@
 {
   DLSyms* pSyms;
   int i,n;
-  pSyms = (DLSyms*) malloc( dlSyms_sizeof() );
-
+  pSyms = dlSymsInit(pLib);
   
-  dlSymsInit(pSyms, pLib);
-
   i = 0, n = dlSymsCount(pSyms);
 
   for (; i < n; ++i) {
